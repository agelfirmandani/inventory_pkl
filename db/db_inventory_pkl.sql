#include <GL/glut.h>   2. #include <math.h>   3.    4. float Cx = 0.0f, Cy = 2.5f, Cz = 0.0f;   5. float Lx = 0.0f, Ly = 2.5f, Lz = -20.0f;   6. float sudut_x = 0.0f;   7. float sudut_x2 = 0.0f;   8. float sudut_z = 0.0f;   9. float sudut_z2 = 0.0f;   10. float sudut_y = 0.0f;   11. float sudut_y2 = 0.0f;   12.    13. float toRadians(float angle){   14.     return angle * M_PI / 180;   15. }   16.    17. class Vector{   18. public:   
  39 
 
 
 
19.     float x, y, z;   20.     void set_values (float startX, float startY, float startZ){   21.         x = startX;   22.         y = startY;   23.         z = startZ;   24.     }   25.     void vectorRotation(Vector refs, float angle){   26.         Vector temp = refs;   27.         float magnitude = sqrt(pow(temp.x, 2) + pow(temp.y, 2) + pow(temp.z, 2)) ;   28.         temp.x = temp.x / magnitude;   29.         temp.y = temp.y / magnitude;   30.         temp.z = temp.z / magnitude;   31.         float dot_product = (x * temp.x)+(y * temp.y)+(z * temp.z);   32.         float cross_product_x = (y * temp.z) - (temp.z * z);   33.         float cross_product_y = -((x * temp.z) - (z * temp.x));   34.         float cross_product_z = (x * temp.y) - (y * temp.x);   35.         float last_factor_rodrigues = 1.0f - cos(toRadians(fmod(angle, 360.0f))) ;   36.         x = (x * cos(toRadians(fmod(angle, 360.0f)))) + (cross_product_x * sin(t oRadians(fmod(angle, 360.0f)))) + (dot_product * last_factor_rodrigues * x);   37.         y = (y * cos(toRadians(fmod(angle, 360.0f)))) + (cross_product_y * sin(t oRadians(fmod(angle, 360.0f)))) + (dot_product * last_factor_rodrigues * y);   38.         z = (z * cos(toRadians(fmod(angle, 360.0f)))) + (cross_product_z * sin(t oRadians(fmod(angle, 360.0f)))) + (dot_product * last_factor_rodrigues * z);   39.     }   40. };   41.    42. Vector sumbu_z, sumbu_x, sumbu_y;   43.    44. void Tabung() {   45.     float amb[] = {0.34f, 0.34f, 0.34f, 1.0f};   46.     float diff[] = {0.41f, 0.41f, 0.41f, 1.0f};   47.     float spec[] = {0.11f, 0.11f, 0.11f, 1.0f};   48.     float shine = 200.0f;   49.     glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, amb);   50.     glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diff);   51.     glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, spec);   52.     glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, shine);   53.     float BODY_LENGTH = 5.0f;   54.     float BODY_RADIUS = 2.0f;   55.     int SLICES = 30;   56.     int STACKS = 30;   57.     GLUquadric *q= gluNewQuadric();   58.     gluCylinder(q, BODY_RADIUS, BODY_RADIUS, BODY_LENGTH, SLICES, STACKS);   59.     gluDisk(q, 0.0f, BODY_RADIUS, SLICES, STACKS);   60.     glTranslatef(0.0f, 0.0f, BODY_LENGTH);   61.     gluDisk(q, 0.0f, BODY_RADIUS, SLICES, STACKS);   62. }   63.    64. static void BigBox(){   65.     float amb[]={0.0f, 0.5f, 0.0f, 1.0f};   66.     float diff[]={0.0f, 0.5f, 0.0f, 1.0f};   67.     float spec[]={0.0f, 0.5f, 0.0f, 1.0f};   68.     float shine=0.0f;   69.     glMaterialfv(GL_FRONT,GL_AMBIENT,amb);   70.     glMaterialfv(GL_FRONT,GL_DIFFUSE,diff);   71.     glMaterialfv(GL_FRONT,GL_SPECULAR,spec);   72.     glMaterialf(GL_FRONT_AND_BACK,GL_SHININESS,shine);   73.     glBegin(GL_QUADS);   74.     glVertex3f(-10000.0f, 0.0f, -10000.0f);   75.     glVertex3f(10000.0f, 0.0f, -10000.0f);   76.     glVertex3f(10000.0f, 0.0f, 10000.0f);   77.     glVertex3f(-10000.0f, 0.0f, 10000.0f);   78.     glEnd();   
  40 
 
 
 
79. }   80.    81. /* ini adalah function untuk melakukan pergerakan.  82. magnitude adalah besarnya gerakan sedangkan direction digunakan untuk menentukan arah.  83. gunakan -1 untuk arah berlawanan dengan vektor awal.  84. */   85.    86. void vectorMovement(Vector toMove, float magnitude, float direction){   87.     float speedX = toMove.x * magnitude * direction;   88.     float speedY = toMove.y * magnitude * direction;   89.     float speedZ= toMove.z * magnitude * direction;   90.     Cx += speedX;   91.     Cy += speedY;   92.     Cz += speedZ;   93.     Lx += speedX;   94.     Ly += speedY;   95.     Lz += speedZ;   96. }   97.    98. void cameraRotation(Vector refer, double angle){   99.     float M = sqrt(pow(refer.x, 2) + pow(refer.y, 2) + pow(refer.z, 2));   100.     float Up_x1 = refer.x / M;   101.     float Up_y1 = refer.y / M;   102.     float Up_z1 = refer.z / M;   103.     float VLx = Lx - Cx;   104.     float VLy = Ly - Cy;   105.     float VLz = Lz - Cz;   106.     float dot_product = (VLx * Up_x1) + (VLy * Up_y1) + (VLz * Up_z1);   107.     float cross_product_x = (Up_y1 * VLz) - (VLy * Up_z1);   108.     float cross_product_y = -((Up_x1 * VLz) - (Up_z1 * VLx));   109.     float cross_product_z = (Up_x1 * VLy) - (Up_y1 * VLx);   110.     float last_factor_rodrigues = 1.0f - cos(toRadians(angle));   111.     float Lx1 = (VLx * cos(toRadians(angle))) + (cross_product_x * sin(toRadians (angle))) + (dot_product * last_factor_rodrigues * VLx);   112.     float Ly1 = (VLy * cos(toRadians(angle))) + (cross_product_y * sin(toRadians (angle))) + (dot_product * last_factor_rodrigues * VLy);   113.     float Lz1 = (VLz * cos(toRadians(angle))) + (cross_product_z * sin(toRadians (angle))) + (dot_product * last_factor_rodrigues * VLz);   114.     Lx = Lx1+Cx;   115.     Ly = Ly1+Cy;   116.     Lz = Lz1+Cz;   117. }   118.    119. void initGL(){   120.     sumbu_z.set_values(0.0f, 0.0f, -1.0f);   121.     sumbu_x.set_values(1.0f, 0.0f, 0.0f);   122.     sumbu_y.set_values(0.0f, 1.0f, 0.0f);   123.     float ambient[] = {1.0f, 1.0f, 1.0f, 1.0f};   124.     float diffuse[] = {1.0f, 1.0f, 1.0f, 1.0f};   125.     float position[] = {1.0f, 1.0f, 1.0f, 0.0f};   126.     glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);   127.     glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);   128.     glLightfv(GL_LIGHT0, GL_POSITION, position);   129.     glEnable(GL_LIGHT0);   130.     glEnable(GL_LIGHTING);   131.     glEnable(GL_DEPTH_TEST);   132.     glClearColor(0.0f, 0.0f, 1.0f, 1.0f);   133.     glShadeModel(GL_SMOOTH);   134. }   135.    136. void reshape(GLsizei width, GLsizei height){   137.     if (height == 0) height = 1;   138.     GLfloat aspect = (GLfloat)width / (GLfloat)height;   139.     glViewport(0, 0, width, height);   
  41 
 
 
 
140.     glMatrixMode(GL_PROJECTION);   141.     glLoadIdentity();   142.     gluPerspective(45.0f, aspect, 1.0f, 20.0f);   143.     glMatrixMode(GL_MODELVIEW);   144.     glLoadIdentity();   145. }   146.    147. void display(){   148.     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);   149.     // Reset the current matrix to the "identity"   150.     glLoadIdentity();   151.     // Move the "drawing cursor" around   152.     gluLookAt(Cx, Cy, Cz,   153.         Lx, Ly, Lz,   154.         sumbu_y.x, sumbu_y.y, sumbu_y.z);   155.     glPushMatrix();   156.     glTranslatef(0.0f, 5.0f, -15.0f);   157.     glRotatef(90.0f, 1.0f, 0.0f, 0.0f);   158.     Tabung();   159.     glPopMatrix();   160.     glPushMatrix();   161.     BigBox();   162.     glPopMatrix();   163.     glFlush();   164.     glutSwapBuffers();   165. }   166.    167. void timer(int value){   168.     glutPostRedisplay();   169.     glutTimerFunc(15, timer, 0);   170. }   171.    172. void keyControl(int k, int x, int y) {   173.     switch(k) {   174.         case GLUT_KEY_UP: //arrow up   175.             vectorMovement(sumbu_y, 2.0f, 1.0f);   176.             break;   177.         case GLUT_KEY_DOWN: //arrow down   178.             vectorMovement(sumbu_y, 2.0f, -1.0f);   179.             break;   180.     }   181. }   182.    183. void keyFunction(unsigned char key, int x, int y){   184.     // Agar fungsi ini bekerja, pastikan CapsLock menyala   185.     switch(key){   186.         case 87: // W   187.             vectorMovement(sumbu_x, 2.0f, 1.0f);   188.             break;   189.         case 83: // S   190.             vectorMovement(sumbu_x, 2.0f, -1.0f);   191.             break;   192.         case 68: // D   193.             vectorMovement(sumbu_z, 2.0f, 1.0f);   194.             break;   195.         case 65: // A   196.             vectorMovement(sumbu_z, 2.0f, -1.0f);   197.             break;   198.         case 74: // J   199.             sudut_z += 15.0f;   200.             sumbu_z.vectorRotation(sumbu_y, sudut_z - sudut_z2); //memutar vecto r sumbu z terhadap x (target, patokan)   201.             sumbu_x.vectorRotation(sumbu_y, sudut_z - sudut_z2);   202.             cameraRotation(sumbu_y, sudut_z - sudut_z2); // look at   203.             sudut_z2 = sudut_z;   
  42 
 
 
 
204.             break;   205.     }   206. }   207.    208. int main(int argc, char **argv){   209.     glutInit(&argc, argv);   210.     glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);   211.     glutInitWindowSize(800, 600);   212.     glutInitWindowPosition(50, 50);   213.     glutCreateWindow("Pertemuan 7");   214.     glutDisplayFunc(display);   215.     glutReshapeFunc(reshape);   216.     initGL();   217.     glutTimerFunc(0, timer, 0);   218.     glutSpecialFunc(keyControl);   219.     glutKeyboardFunc(keyFunction);   220.     glutMainLoop();   221.     return EXIT_SUCCESS;   222. } 